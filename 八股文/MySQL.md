# MySQL

## 基础篇

### 执行一条select语句，期间发生了什么？

学习SQL的时候，大家肯定第一个先学到的就是select查询语句了，比如下面这句查询语句：

```mysql
// 在product表中，查询id=1的记录
select * from product where id = 1;
```

但是有没有想过，MySQL执行一条select查询语句，在MySQL中期间发生了什么？

带着这个问题，我们可以很好的了解MySQL内部的架构，下来我们就在拆解一下MySQL内部的结构，看看内部里的每一个”零件“具体是负责做什么的。

#### MySQL执行流程是怎样的？

MySQL的架构共分为两层：Server层和存储引擎层

- **Server层负责建立连接，分析和执行SQL。**MySQL大多数的核心功能模块都在这实现，主要包括连接器、查询缓存、解析器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函等）和所有跨存储引擎的功能（如存储过程、触发器、视图等）都在Server层实现。

- **存储引擎层负责数据的存储和提取。**支持InnoDB、MyISAM、Memory等多个存储引擎，不同的存储引擎共用一个Server层。现在最常用的存储引擎是InnoDB，从MySQL5.5版本开始，InnoDB成为了MySQL的默认存储引擎。我们常说的引擎数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不同，比如InnoDB支持索引类型是B+树，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是B+树索引。

好了，现在我们对Server层和存储引擎层有了一个简单的认识，接下来，就详细说一条SQL查询语句的执行流程，依次看看每一个功能模块的作用。

#### 第一步：连接器

如果你在Linux系统里要使用MySQL，那你第一步肯定是要先连接MySQL服务，然后才能执行SQL语句，普遍我们都是使用下面这条命令进行连接：

```shell
# -h 指定MySQL服务的IP地址，如果是本地的MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为root
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里输入密码
mysql -h $ip -u $user -p
```

连接的过程需要先经过TCP三次握手，因为MySQL是基于TCP协议进行传输的，如果MySQL服务并没有启动，则会收到报错。

如果MySQL服务正常运行，完成TCP连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。

所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

**如何查看MySQL服务被多少个客户端连接了？**

如果你想知道当前MySQL服务被多少个客户端连接了，你可以执行`show processlist`命令进行查看。

**空闲连接会一直占用着吗？**

当然不是了，MySQL定义了空闲连接的最大空闲时长，由`wait_timeout`参数控制的，默认值时8小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

```mysql
mysql> show variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```

当然，我们自己也可以手动断开空闲的连接，使用的是kill connection + id 的命令。

```mysql
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```

一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

**MySQL的连接数有限制吗？**

MySQL服务支持的最大连接数由max_connection参数控制，比如我的MySQL服务默认是151个，超过这个值，系统就会拒绝接下来的连接请求，并报错提示”Too many connections“。

```mysql
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

MySQL的连接也跟HTTP一样，有短连接和长连接的概念，它们的区别如下：

```tex
// 短连接
连接mysql服务（TCP 三次握手）
执行sql
断开mysql服务（TCP 四次挥手）

// 长连接
连接mysql服务（TCP 三次握手）
执行mysql
执行mysql
执行mysql
...
断开mysql服务（TCP 四次挥手）
```

可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为MySQL在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才释放。如果长连接累计很多，将会导致MySQL服务占用内存太大，有可能会被系统强制杀掉，这样会发生MySQL服务异常重启的现象。

**怎么解决长连接占用内存的问题？**

有两种解决方式。

第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，客户都拿主动重置连接。MySQL 5.7版本实现了`mysql_reset_connection()`函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用mysql_reset_connection函数来重置连接，达到释放内存的效果，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

至此，连接器的工作做完了，简单总结一下：

- 与客户端进行TCP三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

#### 第二步：查询缓存

连接器的工作完成后，客户端就可以向MySQL服务发送SQL语句了，MySQL服务收到SQL语句后，就会解析出SQL语句的第一个字段，看看是什么类型的语句。

如果SQL是查询语句（select语句），MySQL就会先去查询缓存（Query Cache）里查询缓存数据，看看之前有没有执行过这一条命令，这个查询缓存时以key-value形式保存在内存中的，key为SQL查询语句，value为SQL语句查询的结果。

如果查询的语句命中查询缓存，那么就会直接返回value给客户端。如果查询的语句没有命中查询缓存，那么久要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

这么看，查询缓存还挺有用，但是其实查询缓存挺鸡肋的。

对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓存就被清空了，相当于缓存了个寂寞。

所以，MySQL 8.0版本直接将查询缓存删掉了，也就是说MySQL 8.0开始，执行一条SQL查询语句，不会再走到查询缓存阶段了。

对于MySQL 8.0之前的版本，如果想关闭查询缓存，我们可以通过将参数query_cache_type设置成DEMAND。

**TIP：这里说的查询缓存时server层的，也就是MySQL 8.0版本移除的时server层的查询缓存，并不是InnoDB存储引擎中的buffer pool。**

#### 第三步：解析SQL

在正式执行SQL查询语句前，MySQL会先对SQL语句做解析，这个工作交由`解析器`完成。

##### 解析器

解析器会做如下两件事情。

第一件事情，词法分析。MySQL会根据你输入的字符串识别出关键字来，构建出SQL语法树，这样方便后面模块获取SQL类型、表名、字段名、where条件等等。

第二件事情，语法分析。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。

如果我们输入的SQL语句语法不对，就会在解析器这个阶段某错。比如，在一条查询语句中，把from写成了form，这时MySQL解析器就会给报错。

但是注意，表不存在或者字段不存在，并不是解析器里做的，《MySQL 45讲》说是在解析器做的，但是通过MySQL源码（5.7和8.0）分析得出的结论是分析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。

那到底谁来做检测表和字段是否存在的工作呢？别着急，接下来就是了。

#### 第四步：执行SQL

经过解析器后，接着就要进入执行SQL查询语句的流程了，每条`SELECT`查询语句流程主要可以分为下面这三个阶段：

- prepare阶段，也就是预处理阶段；
- optimize阶段，也就是优化阶段；
- execute阶段，也就是执行阶段；

##### 预处理器

我们先来说说预处理阶段做了什么事情。

- 检查SQL查询语句中的表或者字段是否存在；
- 将`select *`中的`*`符号，扩展为表上的所有列；

我下面这条查询语句，test这张表是不存在的，这时MySQL就会在执行SQL查询语句的prepare阶段中报错。

```mysql
mysql> select * from test;
ERROR 1146 (42S02): Table 'mysql.test' doesn't exist
```

#### 优化器

经过预处理阶段后，还需要为SQL查询语句先制定一个执行计划，这个工作交由`优化器`来完成的。

**优化器主要负责将SQL查询语句的执行方案确定下来，**比如在表里面有很多个索引的时候，优化器会基于查询成本的考虑，来决定使用哪个索引。

当然，我们本次的查询语句（select * from product where id = 1 ）很简单，就是选择使用主键索引。

要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个`explain`命令，这样就会输出这条SQL语句的执行计划，然后执行计划中的key就表示执行过程中使用了哪个索引。

如果查询语句的执行计划里的key为null说明没有使用索引，那么就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的。

比如product表只有一个索引就是主键，现在在表中将name设置为普通索引（二级索引）。

这时product表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：

```mysql
select id from product where id > 1 and name like 'i%';
```

这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。

很显然这条查询语句是**覆盖索引**，直接在二级索引就能查到结果（因为二级索引的B+树的叶子节点的数据存储的是主键值），就没必要再主键索引查找了，因为查询主键索引的B+树的成本回比查询二级索引B+树的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。

使用执行计划时，我们可以看到，执行过程中使用了普通索引（name），Exta为Using index，这就是表明使用了覆盖优化索引。

#### 执行器

经历完优化器后，就确定了执行方案，接下来MySQL就真正执行语句了，这个工作是由`执行器`完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

接下来，就用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程。

- 主键索引查询
- 全表扫描
- 索引下推

**主键索引查询**

以本文开头查询语句为例，看看执行器是怎么工作的。

```mysql
select * from product where id = 1;
```

这条查询语句的查询条件用到了主键索引，而且是等值查询，同时唯一主键id是唯一，不会有id相同的记录，所以优化器决定选用访问类型为const进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用read_first_record函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为InnoDB引擎索引查询的接口，把条件`id = 1`交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- 存储引擎通过主键索引的B+树结构定位到id=1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器。

- 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
- 执行器查询的过程是一个while循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用read_record函数指针指向的函数，因为优化器选择的访问类型为const，这个函数指针被指向为一个永远返回-1的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。

至此，这个语句就执行完成了。

**全表扫描**

举个全表扫描的例子：

```mysql
select * from product where name = 'iphone';
```

这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为ALL进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用read_first_record函数指针指向的函数，因为优化器选择的访问类型为all，这个函数指针被指向为InnoDB引擎全扫描的接口，**让存储引擎读取表中的第一条记录**；
- 执行器会判断读到的这条记录的name是不是iphone，如果不是则跳过；如果是则将记录发送给客户端（没错，Server层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候只直接显示所有记录的，是因为客户端时等查询语句查询完成后，才会显示出所有的记录）。
- 执行器查询的过程是一个while循环，所以还会再查一次，会调用read_record函数指针指向的函数，因为优化器选择的访问类型为all，read_record函数指针指向的还是InnoDB引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行层（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
- 一直重复上述过程，知道存储引擎把表中的所有记录读完，然后向执行器（Server层）返回了读取完毕的信息；
- 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。

至此，这个语句就执行完成了。

**索引下推**

在这部分非常适合将索引下推（MySQL 5.6推出的出啊寻优化策略），这样大家都能清楚得知道，`下推`这个动作，下推到了哪里。

索引下推能够减少**二级索引**再查询时的回表操作，提高查询的效率，因为它将Server层部分负责的事情，交给存储引擎层去处理了。

举一个例子，方便大家理解，有一张用户表，对age和reward字段建立了联合索引（age, reward），

现在有下面这条查询语句：

```mysql
select * from t_user where age > 20 and reward = 10000;
```

联合索引当遇到范围查询（>、<）就会停止匹配，也就是age字段能用到联合索引，但是reward字段则无法利用到联合索引。

那么，不使用索引下推（MySQL 5.6之前的版本）时，执行器与存储引擎的执行流程是这样的：

- Server层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到age > 20 的第一条记录；
- 存储引擎根据二级索引的B+树快速定位到这条记录后，获取主键值，然后进行回表操作，将完整的记录返回给Server层；
- Server层在判断该记录的reward是否等于100000，如果成立则将其发送给客户端；否则跳过该记录；
- 接着，继续向存储引擎搜索下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给Server层；
- 如此往复，直到存储引擎把表中的所有记录读完。

可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给Server，接着Server再判断该记录的reward是否等于100000。

而使用索引下推后，判断记录的reward是否等于100000的工作交给了存储引擎层，过程如下：

- Server层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到age > 20 的第一条记录；
- 存储引擎定位到二级索引后，先不执行回表操作，而是判断一下该索引中包含的列（reward列）的条件（reward是否等于100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给Server层。
- Server层在判断其他查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
- 如此反复，直到存储引擎把表中的所有记录读完。

可以看到，使用了所有下推后，虽然reward列无法使用联合索引，但是因为它包含在联合索引（age， reward）里，所以直接在存储引擎过滤出满足reward = 100000的记录后，才会执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。

当你发现执行计划里的Extra部分显示了”Using index condition“，说明使用了索引下推。

#### 总结

执行一条SQL查询语句，期间发生了什么？

- 连接器：建立连接，管理连接，校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0已删除该模块；
- 解析SQL：通过解析器对SQL查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行SQL：执行SQL共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将`select *`中的`*`符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端；

### MySQL一行记录是怎么存储的？

#### MySQL的数据存放在哪个文件？

大家都知道MySQL的数据是保存在磁盘的，那具体是保存在哪个文件呢？

MySQL存储的行为是由存储引擎实现的，MySQL支持多种存储引擎，不同的存储引擎保存的文件自然也不同。

InnoDB是我们常用的存储引擎，也是MySQL默认的存储引擎，所以，本文主要以InnoDB存储引擎展开讨论。

先来看看MySQL数据库的文件存放在哪个目录？

```mysql
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

我们每创建一个database（数据库）都会在/var/lib/mysql目录里面创建一个以database为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。

比如现在有一个名为my_test的database，该database里有一张名为t_order数据库表。

然后我们进入/var/lib/mysql/my_test目录，看看里面有什么文件？

```shell
$ ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```

可以看到，共有三个文件，这三个文件分别代表着：

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm，t_order的表结构会保存在这个问题。在MySQL中建立一张表都会生成一个.frm文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- t_order.ibd，t_order的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数innodb_file_per_table控制的，若设置了参数innodb_file_per_table为1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从MySQL 5.6版本开始，它的默认值就是1了，因此从这个版本之后，MySQL中的每一张表的数据都存放在一个独立的.idb文件。

好了，现在我们知道了一张数据库表的数据是保存在`表名字.ibd`的文件里，这个文件也称为独占表空间文件。

#####  表空间文件的结构是怎样的？

表空间由段（segment）、区（extent）、页（page）、行（row）组成。

1. 行（row）

   数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。后面我们详细介绍InnoDB存储引擎的行格式，也是本文重点介绍的内容。

2. 页（page）

   记录时按照行来存储的，但是数据库的读取并步以`行`为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。

   因此，**InnoDB的数据是按`页`为单位来读写的**，也就是说，当需要读一条数据的时候，并不是将这个行数据从磁盘读出来，而是以页为单位，将其整体读入内存。

   默认每个页的大小为16KB，也就是最多能保证16KB的连续存储空间。

   页是InnoDB存储引擎磁盘管理的最小单位，意味着数据库每次读写都是以16kb为单位的，一次最少从磁盘中读取16K的内容到内存中，一次最少把内存中的16K内容刷新到磁盘中。

   页的类型有很多，常见的有数据页、undo日志页、溢出页等等。数据表中的行记录是用`数据页`来管理的。

   总之知道表中的记录存储在`数据页`里面就行。

3. 区（extent）

   我们知道InnoDB存储引擎是用B+树来组织数据的。

   B+树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机I/O是非常慢的。

   解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序I/O了，那么在范围查询（扫描叶子节点）的时候性能就会很高。

   那具体怎么解决呢？

   **在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为1MB，对于16KB的页来说，连续的64个页会被划分为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序I/O了。**

4. 段（segment）

   表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分配数据段、索引段和回滚段等。

   - 索引段：存放B+树的非叶子节点的区的集合；
   - 数据段：存放B+树的叶子节点的区的集合；
   - 回滚段：存放的是回滚数据的区的集合，后面讲事务隔离的时候就介绍到了MVCC利用了回滚段实现了多版本查询数据。

   好了，终于说完表空间的结构了。接下来，就具体讲一下InnoDB的行格式了。

   之所以要绕一大圈才能讲行记录的格式，主要是想让大家知道行记录时存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。

#### InnoDB行格式有哪些？

行格式（row_format），就是一条记录的存储结构。

InnDB提供了4种行格式，分别是Redundant、Compact、Dynamic和Compressed行格式。

- Redundant是很古老的行格式了，MySQL 5.0版本之前用的行格式了，现在基本没人用了。
- 由于Redundant不是一种紧凑的行格式，所以MySQL 5.0之后引入了Compact行记录存储方式，Compact是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从MySQL 5.1版本之后，行格式默认设置成Compact。
- Dynamic和Compressed两个都是紧凑的行格式，它们的行格式都和Compact差不多，因为都是基于Compact改进一点东西。从MySQL5.7版本之后，默认使用Dynamic行格式。

Redundant行格式这里我就不讲了，因为现在基本没人用了，这次重点介绍Compact行格式，因为Dynamic和Compressed这两个行格式跟Compressed非常像。

所以，弄懂了Compact行格式，之后你们在去了解其他行格式，很快也能看懂。

#### Compact行格式长什么样？

一条完整的记录分为`记录的额外信息`和`记录的真实数据`两个部分。

##### 记录的额外信息

记录的额外信息包含三个部分：变长字段长度列表、NULL值列表、记录头信息。

1. 变长字段长度列表

   varchar(n)和char(n)的区别是什么，相信大家都非常清楚，char是定长的，varchar是变长的，变长字段实际存储的数据的长度（大小）不固定的。

   所以，在存储数据的时候，也要把数据占用的大小存起来，存到`变长字段长度列表`里面，读取数据的时候才能根据这个`变长字段长度列表`去读取对于长度的数据。其他TEXT、BOLB等变长字段也是这么实现的。

   为了展示`变长字段长度列表`具体是怎么保存`变长字段的真实数据占用的字节数`，我们先创建这个一张表，字符集ascii（所以每一个字符占用的1字节），行格式是Compact，t_user表中name和phone字段都是变长字段：

   ```mysql
   CREATE TABLE `t_user` (
     `id` int(11) NOT NULL,
     `name` VARCHAR(20) DEFAULT NULL,
     `phone` VARCHAR(20) DEFAULT NULL,
     `age` int(11) DEFAULT NULL,
     PRIMARY KEY (`id`) USING BTREE
   ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
   ```

   现在t_user表里有三条记录，接下来，我们来看看这三条记录的行格式中的`变长字段长度列表`是怎样存储的。

   先来看第一条记录：

   - name列的值为a，真实数据占用的字节数是1字节，十六进制0x01；
   - phone列的值为123，真实数据占用的字节数是3字节，十六进制0x03；
   - age列和id列不是变长字段，所以这里不用管。

   这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放（等下会说为什么要这么设计），所以`变长字段长度列表`里的内容是[03 01]，而不是[01 03]。

   **为什么`变长字段长度列表`的信息要按照逆序存放？**

   这个设计是有想法的，主要是因为`记录头信息`中指向下一个记录的指针，指向的是下一条记录的`记录头信息`和`真实数据`之间的位置，这样的好处是从左读就是记录头信息，向右读就是真实数据，比较方便。

   `变长字段长度列表`中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对于的字段长度信息可以同时在一个CPU Cache Line中，这样就可以提高CPU Cache的命中率。**

   同样的道理，NULL值列表的信息也需要逆序存放。

   **每个数据库表的行格式都有`变长字段字节数列表`吗**

   其实变长字段字节数列表不是必须的。

   **当数据表没有变长字段的时候，比如全部都是int类型的字段，这时候表里的行格式就不会有`变长字段长度列表`了**，因为没必要，不如去掉以节省空间。

   所以`变长字段长度列表`只出现在数据表有变长字段的时候。

2. NULL值列表

   表中的某些列可能会存储NULL值，如果把这些NULL值都放到记录的真实数据中会比较浪费空间，所以Compact行格式把这些值为NULL的列存储到NULL值列表中。

   如果存在允许NULL值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排序。

   - 二进制位的值为`1`时，代表该列的值为NULL。
   - 二进制位的值为`0`时，代表该列的值不为NULL。

   另外，NULL值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补`0`。

   

   **每个数据库表的行格式都有`NULL值列表`吗？**

   NULL值列表也不是必须的。

   **当数据库表的字段都定义成NOT NULL的时候，这时候表里的行格式就不会有NULL值列表了。**

   所以在设计数据库表的时候，通常都是建议将字段设置为NOT NULL，这样可以至少节省1字节的空间（NULL值列表至少占用1字节空间）。

   

   **`NULL值列表`是固定1字节空间吗？如果这样的话，一条记录有9个字段都是NULL，这时候怎么表示？**

   `NULL值列表`的空间不是固定1字节的。

   当一条记录有9个字段都是NULL，那么就会创建2字节空间的`NULL值列表`，以此类推。

3. 记录头信息

   记录头信息中包含的内容很多，我就不一一举例了，这里说几个比较重要的：

   - delete_mask：标识此条数据是否被删除。从这里可以知道，我们执行delete删除记录的时候，并不会真正的删除记录，只是将这个记录的delete_mask标记位1。
   - next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面也提到了，指向的是下一条记录的`记录头信息`和`真实数据`之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
   - record_type：表示当前记录的类型，0表示普通记录，1表示B+数非叶子节点记录，3表示最小记录，3表示最大记录

   **记录的真实数据**

   记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别位：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。

   - row_id

     如果我们建表的时候指定了主键或者唯一约束列，那么就没有row_id隐藏字段了。如果既没有指定主键，又没有唯一约束，那么InnoDB就会为记录添加row_id隐藏字段。row_id不是必须的，占用6个字节。

   - trx_id

     事务id，表示这个数据是由哪个事务生成的。trx_id是必须的，占用6个字节。

   - row_pointer

     这条记录上一个版本的指针。roll_pointer是必须的，占用7个字节。

     如果你熟悉MVCC机制，你应该就清楚trx_id和roll_pointer的作用了，接着往下看，MVCC一定要掌握，面试经常问。

   **varchar(n)中n最大取值为多少？**

   我们要清楚一点，**MySQL规定除了TEXT、BLOBs这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。**

   也就是说，一行记录除了TEXT、BLOBs类型的列，限制最大为65535字节，注意是一行的总长度，不是一列。

   知道这个前提之后，我们再来看看这个问题：`varchar(n)中n最大取值为多少？`

   varchar(n)字段类型的n代表的是最多存储的字符数量，并不是字节大小。

   要算varchar(n)最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占多少字节，比如ascii字符集，1个字符占用1字节，那么varchar(n)意味着最大能允许存储100字节的数据。

   **单字段的情况**

   前面我们知道了，一行记录最大只能存储65535字节的数据。

   那假设数据库表只有一个varchar(n)类型的列且字符集是ascii，在这种情况下，varchar(n)中n最大取值是65535吗？

   不着急说结论，我们先来做个实验验证一下。

   我们定义一个varchar(65535)类型的字段，字符集为ascii的数据库表。

   ```mysql
   CREATE TABLE test ( 
   `name` VARCHAR(65535)  NULL
   ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
   ```

   结果是创建失败了，得到的报错信息是`一行数据的最大字节数是65535（不包含TEXT、BLOBs这种大对象类型），其中包含了storage overhead`。

   问题来了，这个storage overhead是什么呢？其实就是`变长字段长度列表`和`NULL值列表`，也就是说**一行数据的最大字节数65535，其实是包含`变长字段长度列表`和`NULL值列表`所占用的字节数。**所以，我们在算varchar(n)最大值时，需要减去storage overhead占用的字节数。

   这是因为我们存储字段累心为varchar(n)的数据时，其实分成了三个部分来存储：

   - 真实数据
   - 真实数据占用的字节数
   - NULL标识，如果不允许为NULL，这部分不需要

   **本次案例中，`NULL值列表`所占用的字节数是多少？**

   前面我们创建表的时候，字段是允许为NULL的，所以**会用1字节来表示`NULL值列表`**。

   **本次案例中，`变长字段长度列表`所占用的字节数是多少？**

   `变长字段长度列表`所占用的字节数=所有`变长字段长度`占用的字节数之和。

   所以，我们要先知道每个变长字段的`变长字段长度`需要用多少字节表示？具体情况分为：

   - 条件一：如果变长字段允许存储的最大字节数小于等于255字节，就会用1字节表示`变长字段长度`；
   - 条件二：如果变长字段允许存储的最大字节数大于255字节，就会用2字节表示`变长字段长度`；

   我们这里字段类型时varchar(65535)，字符集是ascii，所以代表着变长字段允许存储的最大字节数是65535，符合条件二，所以会用2字节来表示`变长字段长度`。

   **因为我们这个案例时只有一个变长字段，所以`变长字段长度列表`=1个`变长字段长度`占用的字节数，也就是2字节**

   因为我们在算varchar(n)最大值时，需要减去`变长字段长度列表长度`和`NULL值列表`所占用的字节数。所以，**在数据库表中有一个varchar(n)字段且字符集时ascii的情况下，varchar(n)最大值=65535-2-1=65532。**

4. 

5. 